//: ### 什么是接口隔离原则（Interface Segregation Principle）?
//:
//: 接口隔离原则的定义：
//:
//: * 客户端不应该依赖它不需要的接口
//:
//: * 类间的依赖关系应该建立在最小的接口上

var str = "Hello, Interface Segregation Principle(接口隔离原则)，简称ISP"

print(str)

//: 接口隔离原则是对接口（协议）进行规范约束，包含以下4层含义：
//:
//: 1. 接口尽量小
//:
//: 尽量不出现臃肿的接口（协议），但是也不能太小，需要有个度，这个度的准则就是不能违反单一职责原则。例如，我们有一个电话类，UML类图如下:
//:
//: ![接口隔离原则](接口隔离原则(ISP).png)
//:
//: 从类图中可以看到，我们的`Phone` 类由`ConnectionManager`和`DataTransfer`两个类组成，也就是连接管理和数据传输两个业务模块组成。
//: 在`IConnectionManager`接口汇总，我们有拨通和挂机两个功能，对于这两个功能，我们有没有必要拆分成两个接口，一个负责拨通，一个负责挂电话呢？
//: 显然我们拆分到更细的接口时，我们功能结构反而会变得更加复杂，从业务逻辑上来讲，拨通电话和挂断电话已经是最小的业务单位了。所以在考虑接口粒度时，
//: 首先要满足单一职责原则，再去满足接口隔离原则。
//:
//: 2. 接口要高内聚
//:
//: 高内聚就是提高接口、类、模块的处理能力，减少对外的交互，具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口（协议）是对外的承诺，
//: 承诺越少对系统的开发越有利，变更的风险也就越 少，同时也有利于降低成本。
//:
//: 3. 定制服务
//:
//: 一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口(并不一定就是Java中定义的Interface，也可能是一个类或单纯的数据交换)，
//: 我们设计时就需要为各个访问者(即客户端)定制服务，什么是定制服务？定制服务就是单独为一个个体提供服务。
//:
//: 4. 接口设计是有限度的
//:
//: 接口的设计粒度越小，系统越灵活，但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，所以接口设计一定要适度。
//:
//: ### 总结
//:
//: 接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。
//: 但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下几个规则来衡量：
//:
//: * 一个接口只服务于一个子模块或业务逻辑
//:
//: * 通过业务逻辑压缩接口中的public方法，避免接口臃肿
//:
//: * 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理
//:
//: * 深入了解业务逻辑，业务逻辑不同，接口拆分逻辑也不同
